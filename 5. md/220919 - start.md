## 220919 - start



#### SW 문제 해결 역량이란 무엇인가?

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력

- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.

- 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

- 문제 해결 역량은 추상적인 기술이다.

---

#### 문제 해결 능력을 훈련하기 위해서는

- 일부 새로운 언어, 프레임워크, 개발 방법론만을 배워나가는 것만으로 충분하지않다. 이들을 조합해 나가는 방법을 배워야 하지만 쉽지 않다.

- 경험을 통해서 나아지리라 막연히 짐작만 한다. 그러나 경험에서는 문제 해결 능력을 개발 할 수 있는 상황이 항상 주어지는 것이 아니며 또한 그런 상황에서 자기 개발을 하기는 쉽지 않다.

- 상황을 인위적으로 만들어 훈련해야 한다. 즉 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시킬 수 있는 훈련이 필요하다.

---

#### 문제 해결 과정

- 문제를 읽고 이해한다,

- 문제를 익숙한 용어로 재정의한다.

- 어떻게 해결할지 계획을 세운다.

- 계획을 검증한다.

- 프로그램으로 구현한다.

- 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

---

#### 문제 해결 전략

- 직관과 체계적인 접근

---

#### 체계적인 접근을 위한 질문들

- 비슷한 문제를 풀어본 적이 있던가?

- 단순한 방법에서 시작할 수 있을까?

- 문제를 단순화 할 수 있을까?

- 그림으로 그려 볼 수 있을까?

- 수식으로 표현 할 수 있을까?

- 문제를 분해 할 수 있을까?

- 뒤에서부터 생각해서 문제를 풀 수 있을까?

- 틀정 형태의 답만을 고려할 수 있을까?

---

## 복잡도 분석

#### 알고리즘?

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

---

#### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
  
  - 공간적 효율성을 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
  
  - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
  
  - 효율성을 뒤집어 표현하면 복잡도가 된다. 복잡도가 높을수록 효율성은 저하된다.

- 시간적 복잡도 분석
  
  - 하드웨어 환경에 따라 처리시간이 달라진다.
    
    - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
    
    - 입출력 장비의 성능, 공유여부
  
  - 소프트웨어 환경에 따라 처리시간이 달라진다.
    
    - 프로그램 언어의 종류
    
    - 운영체제, 컴파일러의 종류
  
  - 이러한 환경적 차이로 인해 분석이 어렵다.

---

#### 자주 사용하는 O-표기 (빅오)

- O(1) = 상수 시간(Constant time)

- O(logn) = 로그(대수) 시간

- O(n) = 선형 시간

- O(nlogn) = 로그 선형 시간

- O(n2) = 제곱 시간

- O(n3) = 세제곱 시간

- O(2n) = 지수 시간

---

#### 왜 효율적인 알고리즘이 필요한가

- 10억 개의 숫자를 정렬하는데 pc에서 O(n2) 알고리즘은 300여 년이 걸리는 반면 O(nlogn) 알고리즘은 5분 만에 정렬한다.

- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.

- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

---

## 표준 입출력 방법

#### python3 표준입출력

---

## 비트 연산

---

#### 비트 연산자

- & = 비트단위로 AND 연산을 한다. (0과 AND를 하면 무조건 0)

- | = 비트 단위로 OR 연산을 한다.

- ^ = 비트 단위로 XOR 연산을 한다. (같으면 0 다르면 1)

- ~ = 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.

- 

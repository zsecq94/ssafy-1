# Python_01_파이썬 기초

- 구조화: 어떠한 개념이 있으면, 해당 개념과 하위 개념들을 잘 묶어서 머릿속에 저장하는 것

#### 프로그래밍
- 프로그램: 특정 작업을 수행하는 일련의 명령어들의 모음
- 프로그래밍: 컴퓨터에게 일을 시키기 위해서 프로그램을 만드는 행위
- 언어의 특징: 기본적인 규칙과 문법이 존재, 사람이 이해할 수 있는 문자로 구성
- 소스코드: 프로그래밍 언어로 작성된 프로그램
- 번역기: 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역, 파이썬의 경우는 인터프리터를 사용(통역하듯이 1줄씩 변환)

- IDE: 통합 개발 환경의 약자로 개발에 필요한 다양하고 강력한 기능들을 모아둔 프로그램
- 변수: 복잡한 값들을 쉽게 사용할 수 있음(추상화), 코드의 가독성 증가

#### 각 변수의 값을 바꿔서 저장하기
1. 임시 변수 활용
```python
x, y = 10, 20
tmp = x
x = y
y = tmp
```
2. Pythonic!
```python
x, y = 10, 20
y, x = x, y
```

#### 실수 연산시 주의할 점(부동 소수점)
```python
print(abs(a - b) <= 1e-10)
import math
print(math.isclose(a, b))
```

#### string interpolation
- %-formatting
print(‘Hello, %s’ % name)
- str.format()
print(‘hello, {}! 성적은 {}’.format(name, score))
- f-strings
print(f’hello {today:%y}년‘)

#### 컨테이너
- 여러 개의 값을 담을 수 있는 것(객체)으로, 서로 다른 자료형을 저장할 수 있음
- 순서가 있다 != 정렬되어 있다
- 시퀀스형: 리스트, 튜플, 레인지
- 비시퀀스형: 세트, 딕셔너리

- 가변형: 리스트, 세트, 딕셔너리
- 불변형: 튜플, 레인지

#### range
- 기본형: range(n) 0부터 n-1까지의 숫자의 시퀀스
- 범위 지정: range(n, m) n부터 m-1까지의 숫자의 시퀀스
- 범위 및 스텝 지정: range(n, m, s) n부터 m-1까지 s만큼 증가시키며 숫자의 시퀀스

#### 셋(set) 연산자
- 인덱스를 이용한 접근 불가능
- |: 합집합
- &: 교집합
- -: 차집합
- ^: 대칭차집합

# Python_02_조건문_반복문_함수_모듈

#### 조건 표현식(삼항 연산자)
- true인 경우 값 if 조건 else false인 경우 값

#### 딕셔너리 순회
```python
grades = {'john': 80, 'eric': 90}
for student in grades:
	print(student, grades[student])
```

#### enumerate()
- 인덱스와 객체를 쌍으로 담은 열거형 객체 반환(튜플형)
- print(list(enumerate(members, start = 1))) # start를 지정하면 해당 값부터 순차적으로 증가

#### list comprehension
```python
cubic_list = []
for number in range(1,4):
    cubic_list.append(number**3)
==
cubic_list = [number ** 3 for number in range(1, 4)]
# [1, 8, 27]
```

#### Dictionary comprehension
```python
cubic_dict = {}
for number in range(1,4):
    cubic_dict[number] = number ** 3
=
cubic_dict = {number: number ** 3 for number in range(1,4)}
```

#### 함수를 왜 사용할까?
- 분해: 기능을 분해하고 재사용 가능하게 만들고
- 추상화: 복잡한 내용을 모르더라도 사용할 수 있도록(스마트폰) 재사용성과 가독성, 생산성

#### 함수 기본 구조
- 선언과 호출, 입력, 문서화, 범위, 결과값

#### 함수의 입력(input)
- parameter: 함수를 정의할 때, 함수 내부에서 사용되는 변수
- Argument: 함수를 호출할 때, 넣어주는 값
- 가변 키워드 인자
```python
def family(**kwargs):
	for key, value in kwargs.items():
		print(key, ":", value)
```

#### namespace(LEGB)
- local scope: 지역 범위(현재 작업 중인 범위), 함수 내부에서만 참조 가능
- enclosed scope: 지역 범위 한 단계 위 범위
- global scope: 최상단에 위치한 범위, 코드 어디에서든 참조할 수 있는 공간
- Bulit-in scope: 모든 것을 담고 있는 범위(정의하지 않고 사용할 수 있는 모든 것)

#### global 관련 에러
- parameter에 global 사용 불가

#### filter
- filter(function, iterable)
- 순회 가능한 데이터구조의 모든 요소에 함수 적용하고, 그 결과가 True인 것들을 filter object로 반환

#### lambda 함수
```python
triangle_area = lambda b, h : 0.5 * b * h
```

#### 재귀 함수
```python
def factorial(n):
	if n == 0 or n == 1:
		return 1
	else:
		return n * factorial(n-1)
```

- 모듈: 다양한 기능을 하나의 파일로, 특정 기능을 하는 코드를 파이썬 파일(.py) 단위로 작성한 거
- 패키지: 다양한 파일을 하나의 폴더로, 특정 기능과 관련된 여러 모듈의 집합, 패키지 안에는 또 다른 서브 패키지를 포함
```python
from package import module
```
- 라이브러리: 다양한 패키지를 하나의 묶음으로
- pip: 이것을 관리하는 관리자
- 가상환경: 패키지의 활용 공간

# Python_03_데이터구조

#### 문자열 조회/탐색 및 검증 메서드
- s.find(x): x의 첫 번째 위치 반환, 없으면 -1 반환
- s.index(x): x의 첫 번째 위치 반환, 없으면 오류

#### 리스트 메서드
- L.insert(i, x): 리스트 인덱스 i에 항목 x를 삽입
- L.pop(i): 리스트의 인덱스 i에 있는 항목을 제거 후 반환
- L.extend(m): 순회형 m의 모든 항목들의 리스트 끝에 추가 (+=과 같은 기능)
- .sort()와 sorted의 차이: .sort()는 원본 변경

#### 셋 메서드
- s.pop(): 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거, set이 비어있으면 에러
- s.update(t): 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가
- s.isdisjoint(t): 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True반환(서로소)
- s.issubset(t): 셋 s가 셋 t의 하위 셋인 경우, True 반환
- s.issuperset(t): 셋 s가 셋 t의 상위 셋인 경우, True 반환

#### 딕셔너리 메서드
- d.get(k): 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 None을 반환
- d.update(key=value): 값을 제공하는 key, value로 덮어쓰기

#### 할당
- 대입 연산자(=): 해당 객체에 대한 객체 참조를 복사, 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

#### 얕은 복사
- slice 연산자([:]) 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
```python
import copy
a = [1, 2, ['a','b']]
b = a[:]
print(a, b) # [1, 2, ['a','b']] [1, 2, ['a','b']]
b[2][0] = 0
print(a, b) # [1, 2, [0,'b']] [1, 2, [0,'b']]
```

#### 깊은 복사
```python
import copy
a = [1, 2, ['a','b']]
b = copy.deepcopy(a)
print(a, b) # [1, 2, ['a','b']] [1, 2, ['a','b']]
b[2][0] = 0
print(a, b) # [1, 2, ['a','b']] [1, 2, [0,'b']]
```

# Python_04_OOP

#### 객체 지향 프로그래밍
- OOP는 컴퓨터 프로그래밍의 패러다임 중 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메세지를 주고받고, 데이터를 처리할 수 있다.
- 프로그램을 여러 개의 독립된 객체들과 그 객체 간의 상호작용으로 파악하는 프로그래밍 방법
- 장점: 클래스 단위로 모듈화시켜 개발할 수 있으므로 많은 인원이 참여하는 대규모 소프트웨어 개발에 적합, 필요한 부분만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉬움
- 단점: 설계 시 많은 노력과 시간이 필요함, 실행 속도가 상대적으로 느림

#### OOP 기초
- 객체: 클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것, 속성과 행동으로 구성된 모든 것
- 클래스를 만든다 == 타입을 만든다
- 객체는 특정 타입의 인스턴스이다.
- 객체의 특징: 타입, 속성, 조작법

#### 메서드
- 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)
- 생성자 메서드: 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드, 인스턴스 변수들의 초기값을 설정
- 인스턴스 메서드: 호출한 인스턴스를 의미하는 self 매개 변수를 통해 인스턴스를 조작
- 클래스 메서드: 클래스를 의미하는 cls 매개 변수를 통해 클래스를 조작
- 스태틱 메서드: 속성을 다루지 않고 단지 기능(행동)만을 하는 메서드를 정의할 때 사용(@staticmethod), 객체 상태나 클래스 상태 수정 불가능

#### 객체지향의 핵심 4가지
- 추상화: 현실 세께를 프로그램 설계에 반영, 복잡한 것은 숨기고, 필요한 것만 들어내기
- 상속: 두 클래스 사이 부모-자식 관계를 정립하는 것, 모든 파이썬 클래스는 object를 상속 받음
	- 하위 클래스는 상위 클래스에 정의된 속성, 행동, 관계 및 제약 조건을 모두 상속 받음
	- 코드 재사용성이 높아짐
	- super(): 자식 클래스에서 부모 클래스를 사용하고 싶은 경우(\__init__)
- 다형성: 동일한 메서드가 크래스에 따라 다르게 행동할 수 있음을 의미, 서로 다른 클래스에 속해있는 객체들이 동일한 메시지에 대해 다른 방식으로 응답할 수 있음
	- 메서드 오버라이딩: 상속받은 메서드를 재정의, 이름과 기본 기능은 그대로 사용하지만, 특정 기능을 바꾸고 싶을 때 사용
- 캡슐화: 객체의 일부 구현 내용에 대해 외부로부터의 직접적인 액세스를 차단
	- public member: 언더바 없이 시작하는 메서드나 속성, 어디서나 호출이 가능, 하위클래스 override 허용, 일반적으로 작성되는 메서드와 속성의 대다수를 차지
	- protected member: 언더바 하나로 시작하는 메서드나 속성, 암묵적 규칙에 의해 부모 클래스 내부와 자식 클래스에서만 호출 가능
	- private member: 언더바 2개로 시작하는 메서드나 속성, 본 클래스 내부에서만 사용이 가능, 하위클래스 상속 및 호출 불가능, 외부 호출 불가능
	

